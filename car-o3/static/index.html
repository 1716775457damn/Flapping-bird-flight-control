<!DOCTYPE html>
<html>

<head>
    <title>ESP32 MPU6050 数据可视化</title>
    <meta charset="UTF-8">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
            color: #ffffff;
        }

        .container {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 10px;
            padding: 10px;
            max-width: 100%;
            height: 100vh;
            margin: 0;
        }

        .sidebar {
            background: #2d2d2d;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow-y: auto;
            max-height: calc(100vh - 20px);
        }

        .main-content {
            display: grid;
            grid-template-rows: 60% 40%;
            gap: 10px;
            height: calc(100vh - 20px);
        }

        .visualization-container {
            width: 100%;
            height: 60vh;
            position: relative;
            background: #1a1a1a;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        #visualization {
            width: 100% !important;
            height: 100% !important;
            background: transparent;
            display: block;
        }

        .charts-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            background: #2d2d2d;
            border-radius: 8px;
            padding: 10px;
            height: calc(40vh - 20px);  /* 确保图表有固定高度 */
        }

        .chart {
            background: #3d3d3d;
            border-radius: 6px;
            min-height: 200px;  /* 确保最小高度 */
            width: 100%;
        }

        .data-item {
            background: #3d3d3d;
            padding: 8px;
            border-radius: 6px;
            font-size: 0.9em;
        }

        .value {
            font-size: 16px;
            font-weight: bold;
            color: #4CAF50;
            font-family: monospace;
            margin: 2px 0;
        }

        .label {
            color: #aaa;
            font-size: 12px;
            margin-bottom: 2px;
        }

        .status {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 15px;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 0.9em;
            text-align: center;
        }

        .connected {
            background: #4CAF50;
            color: white;
        }

        .disconnected {
            background: #f44336;
            color: white;
        }

        .calibration-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #2d2d2d;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }

        .btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }

        .btn:hover {
            background: #45a049;
        }

        .btn:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .calibration-status {
            color: #fff;
            margin-top: 10px;
            font-size: 12px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 2000;
        }

        .modal-content {
            position: relative;
            background-color: #2d2d2d;
            margin: 15% auto;
            padding: 20px;
            width: 80%;
            max-width: 600px;
            border-radius: 8px;
            color: white;
        }

        .modal-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .modal-text {
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .modal-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
        }

        .modal-btn:hover {
            background: #45a049;
        }

        .calibration-steps {
            margin-top: 10px;
            padding: 5px;
            border: 1px solid #555;
            border-radius: 4px;
        }

        .step {
            padding: 8px;
            margin: 4px 0;
            border-radius: 3px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .step.active {
            background: #4CAF50;
        }

        .step.completed {
            background: #45a049;
            opacity: 0.7;
        }

        .axis-indicator {
            display: inline-flex;
            gap: 5px;
        }

        .axis {
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
        }

        .axis.highlight {
            background: #ffeb3b;
            color: #000;
        }

        .arrow {
            font-size: 20px;
            margin: 0 5px;
        }

        .stability-indicator {
            margin-top: 10px;
            padding: 5px;
            border-radius: 3px;
            text-align: center;
            display: none;
        }

        .stability-indicator.stable {
            background: #4CAF50;
            display: block;
        }

        .stability-indicator.unstable {
            background: #f44336;
            display: block;
        }

        .calibration-guide {
            margin: 20px 0;
            text-align: center;
        }

        .guide-image {
            width: 200px;
            height: 200px;
            margin: 10px auto;
            position: relative;
            border: 2px solid #555;
            border-radius: 8px;
        }

        .guide-arrow {
            position: absolute;
            font-size: 24px;
            color: #ffeb3b;
            font-weight: bold;
        }

        .guide-text {
            margin-top: 10px;
            font-size: 14px;
            line-height: 1.5;
        }

        .guide-model-container {
            width: 200px;
            height: 200px;
            margin: 10px auto;
            position: relative;
            border: 2px solid #555;
            border-radius: 8px;
            background: #000;
        }

        .angle-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px;
            border-radius: 4px;
            font-size: 12px;
            color: #fff;
        }
    </style>
</head>

<body>
    <div id="calibrationModal" class="modal">
        <div class="modal-content">
            <div class="modal-title">姿态校准</div>
            <div class="modal-text" id="modalText">请按照提示完成校准步骤</div>
            <button class="modal-btn" id="modalBtn">确定</button>
        </div>
    </div>

    <div class="calibration-panel">
        <button id="startCalibration" class="btn">开始校准</button>
        <button id="resetOrientation" class="btn">重置姿态</button>
        <div class="calibration-status" id="calibrationStatus"></div>
        <div class="calibration-steps" id="calibrationSteps">
            <div class="step" data-step="1">1. 水平放置（正面朝上）</div>
            <div class="step" data-step="2">2. 垂直放置（正面朝Y轴）</div>
            <div class="step" data-step="3">3. 侧放（正面朝X轴）</div>
            <div class="step" data-step="4">4. 旋转（正面朝下）</div>
        </div>
    </div>
    <div class="container">
        <div class="sidebar">
            <div style="text-align: center;">
                <div id="connection-status" class="status disconnected">未连接</div>
            </div>
            <div class="data-item">
                <div class="label">线性加速度</div>
                <div id="linear-accel-x" class="value">0.00 m/s²</div>
                <div id="linear-accel-y" class="value">0.00 m/s²</div>
                <div id="linear-accel-z" class="value">0.00 m/s²</div>
            </div>
            <div class="data-item">
                <div class="label">角速度</div>
                <div id="gyro-x" class="value">0.00 °/s</div>
                <div id="gyro-y" class="value">0.00 °/s</div>
                <div id="gyro-z" class="value">0.00 °/s</div>
            </div>
            <div class="data-item">
                <div class="label">姿态角</div>
                <div id="orientation-x" class="value">0.00°</div>
                <div id="orientation-y" class="value">0.00°</div>
                <div id="orientation-z" class="value">0.00°</div>
            </div>
            <div class="data-item" style="border: 2px solid #ff0000;">
                <div class="label">电机控制</div>
                <div style="display: flex; flex-direction: column; gap: 10px; padding: 10px;">
                    <!-- 遥感控制 -->
                    <div class="joystick-container"
                        style="width: 150px; height: 150px; background: #3d3d3d; border-radius: 50%; position: relative; margin: 10px auto;">
                        <div id="joystick"
                            style="width: 50px; height: 50px; background: #4CAF50; border-radius: 50%; position: absolute; top: 50px; left: 50px; cursor: pointer;">
                        </div>
                    </div>

                    <!-- 按键控制说明 -->
                    <div style="text-align: center; margin: 10px 0; color: #aaa;">
                        <div>键盘控制：</div>
                        <div>W/S - 前进/后退</div>
                        <div>A/D - 左转/右转</div>
                        <div>空格 - 停止</div>
                    </div>

                    <button class="btn" onclick="setMotor(1, 100)" style="background: #4CAF50;">正转</button>
                    <button class="btn" onclick="setMotor(1, 0)" style="background: #f44336;">停止</button>
                    <button class="btn" onclick="setMotor(1, -100)" style="background: #4CAF50;">反转</button>
                    <div style="text-align: center; margin: 5px 0;">
                        速度: <span id="motorSpeed" class="value">0</span>%
                    </div>
                    <input type="range" style="width: 100%; margin: 5px 0;" id="speedSlider" min="-100" max="100"
                        value="0" oninput="updateMotorSpeed(this.value)">
                </div>
            </div>
        </div>
        <div class="main-content">
            <div class="visualization-container">
                <div id="visualization"></div>
            </div>
            <div class="charts-container">
                <div class="chart" id="accel-chart"></div>
                <div class="chart" id="gyro-chart"></div>
            </div>
        </div>
    </div>

    <script>
        // 添加全局变量
        let scene, camera, renderer, cube, orbitControls;
        let pathGeometry, pathLine, pathMaterial;
        const pathPoints = [];
        const MAX_PATH_POINTS = 1000;

        // 添加平滑参数
        const ROTATION_SMOOTHING = 0.2;
        const POSITION_SMOOTHING = 0.2;
        const POSITION_SCALE = 20;
        const MIN_MOVEMENT = 0.001;

        // 添加轨迹相关配置
        const pathConfig = {
            maxPoints: 500,        // 减少最大点数以提高性能
            smoothing: 20,         // 减少平滑点数以提高性能
            minDistance: 0.05,     // 增加最小距离阈值，减少点数
            color: 0x00ff00,      // 轨迹颜色
            width: 2,             // 轨迹线宽
            opacity: 0.8,         // 轨迹透明度
            fadeOut: true,        // 启用轨迹渐隐
            fadeSpeed: 0.995      // 渐隐速度
        };

        // 数据缓冲
        const dataBuffer = {
            time: [],
            accel: { x: [], y: [], z: [] },
            gyro: { x: [], y: [], z: [] }
        };
        const BUFFER_SIZE = 100;

        // 修改服务器配置
        const serverConfig = {
            host: window.location.hostname || 'localhost',  // 动态获取当前主机名
            port: window.location.port || 5000,            // 使用当前端口或默认5000
            maxRetries: 3,                                 // 最大重试次数
            retryDelay: 2000,                             // 重试延迟（毫秒）
            debug: true                                    // 启用调试日志
        };

        let retryCount = 0;

        // 修改校准相关变量
        let calibrationOffset = {
            horizontal: { x: 0, y: 0, z: 0 },
            vertical: { x: 0, y: 0, z: 0 },
            side: { x: 0, y: 0, z: 0 },
            rotate: { x: 0, y: 0, z: 0 },
            initial: { x: 0, y: 0, z: 0 }
        };
        let isCalibrating = false;
        let calibrationStep = 0;
        const CALIBRATION_SAMPLES = 30;
        let calibrationData = {
            x: [], y: [], z: [],
            gx: [], gy: [], gz: []
        };

        // 在全局变量区域添加
        let isCollecting = false;  // 控制数据采集的标志

        // Three.js初始化函数
        function initVisualization() {
            console.log('Initializing visualization...');
            // 创建场景
            scene = new THREE.Scene();
            
            // 添加环境光和平行光
            const ambientLight = new THREE.AmbientLight(0x666666);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);
            
            // 获取容器
            const container = document.getElementById('visualization');
            if (!container) {
                console.error('Visualization container not found');
                return;
            }
            
            // 确保容器尺寸正确
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // 创建相机
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);
            
            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ 
                antialias: true
            });
            renderer.setSize(width, height);
            renderer.setClearColor(0x111111);
            
            // 清除容器中的旧内容
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            
            container.appendChild(renderer.domElement);
            
            // 创建网格
            const gridHelper = new THREE.GridHelper(20, 20, 0x404040, 0x303030);
            gridHelper.material.opacity = 0.5;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
            
            // 创建坐标轴
            const axesHelper = new THREE.AxesHelper(10);
            scene.add(axesHelper);
            
            // 创建立方体
            const geometry = new THREE.BoxGeometry(4, 1, 2);
            const material = new THREE.MeshPhongMaterial({
                color: 0x4CAF50,
                wireframe: false,
                transparent: true,
                opacity: 0.8,
                shininess: 30
            });
            cube = new THREE.Mesh(geometry, material);
            scene.add(cube);
            
            // 创建OrbitControls
            orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
            
            // 开始动画循环
            animate();
        }
        
        // 修改窗口大小调整处理函数
        function onWindowResize() {
            const container = document.getElementById('visualization');
            if (!container || !camera || !renderer) return;
            
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            console.log('Resizing to:', width, height);
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }
        
        // 修改动画循环函数
        function animate() {
            requestAnimationFrame(animate);
            
            if (orbitControls && orbitControls.enabled) {
                orbitControls.update();
            }
            
            if (scene && camera && renderer && (
                orbitControls.enabled || 
                Math.abs(cube.rotation.x - targetRotation.x) > MIN_MOVEMENT ||
                Math.abs(cube.rotation.y - targetRotation.y) > MIN_MOVEMENT ||
                Math.abs(cube.rotation.z - targetRotation.z) > MIN_MOVEMENT
            )) {
                renderer.render(scene, camera);
            }
        }
        
        // 更新MPU可视化
        function updateVisualization(data) {
            if (cube) {
                if (!data || !data.orientation) {
                    console.warn('Invalid orientation data');
                    return;
                }

                // 使用lerp进行平滑插值
                const targetRotation = {
                    x: data.orientation.x * Math.PI / 180,
                    y: data.orientation.y * Math.PI / 180,
                    z: data.orientation.z * Math.PI / 180
                };
                
                cube.rotation.x += (targetRotation.x - cube.rotation.x) * ROTATION_SMOOTHING;
                cube.rotation.y += (targetRotation.y - cube.rotation.y) * ROTATION_SMOOTHING;
                cube.rotation.z += (targetRotation.z - cube.rotation.z) * ROTATION_SMOOTHING;
            }
        }

        // 初始化图表
        function initCharts() {
            // 加速度图表配置
            const accelLayout = {
                title: '线性加速度',
                paper_bgcolor: '#2d2d2d',
                plot_bgcolor: '#3d3d3d',
                font: {
                    color: '#ffffff'
                },
                xaxis: {
                    title: '时间 (s)',
                    gridcolor: '#666666',
                    showgrid: true
                },
                yaxis: {
                    title: '加速度 (m/s²)',
                    gridcolor: '#666666',
                    showgrid: true
                },
                showlegend: true,
                legend: {
                    x: 1,
                    y: 1
                },
                margin: { t: 40, l: 60, r: 40, b: 40 }
            };

            // 角速度图表配置
            const gyroLayout = {
                title: '角速度',
                paper_bgcolor: '#2d2d2d',
                plot_bgcolor: '#3d3d3d',
                font: {
                    color: '#ffffff'
                },
                xaxis: {
                    title: '时间 (s)',
                    gridcolor: '#666666',
                    showgrid: true
                },
                yaxis: {
                    title: '角速度 (°/s)',
                    gridcolor: '#666666',
                    showgrid: true
                },
                showlegend: true,
                legend: {
                    x: 1,
                    y: 1
                },
                margin: { t: 40, l: 60, r: 40, b: 40 }
            };

            // 创建加速度图表
            Plotly.newPlot('accel-chart', [
                {
                    name: 'X轴',
                    x: [],
                    y: [],
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: '#ff4444' }
                },
                {
                    name: 'Y轴',
                    x: [],
                    y: [],
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: '#44ff44' }
                },
                {
                    name: 'Z轴',
                    x: [],
                    y: [],
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: '#4444ff' }
                }
            ], accelLayout);

            // 创建角速度图表
            Plotly.newPlot('gyro-chart', [
                {
                    name: 'X轴',
                    x: [],
                    y: [],
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: '#ff4444' }
                },
                {
                    name: 'Y轴',
                    x: [],
                    y: [],
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: '#44ff44' }
                },
                {
                    name: 'Z轴',
                    x: [],
                    y: [],
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: '#4444ff' }
                }
            ], gyroLayout);
        }

        // 修改DOM加载完成后的初始化函数
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing...');
            try {
                // 先初始化Three.js场景
                initVisualization();
                // 然后初始化其他组件
                initCharts();
                initJoystick();
                connectWebSocket();
            } catch (error) {
                console.error('初始化失败:', error);
            }
        });

        // WebSocket连接函数
        function connectWebSocket() {
            ws = new WebSocket(`ws://${window.location.hostname}:8765`);
            
            ws.onopen = function() {
                console.log('WebSocket connected');
                document.getElementById('connection-status').className = 'status connected';
                document.getElementById('connection-status').textContent = '已连接';
                retryCount = 0;
            };
            
            ws.onclose = function() {
                console.log('WebSocket disconnected');
                document.getElementById('connection-status').className = 'status disconnected';
                document.getElementById('connection-status').textContent = '未连接';
                if (retryCount < serverConfig.maxRetries) {
                    retryCount++;
                    setTimeout(connectWebSocket, serverConfig.retryDelay);
                } else {
                    console.error('WebSocket连接失败，已达到最大重试次数');
                }
            };
            
            ws.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === 'mpu_data') {
                        updateVisualization(data.data);
                        updateCharts(data.data);
                        updateDisplayValues(data.data);
                    }
                } catch (error) {
                    console.error('Error processing WebSocket message:', error);
                }
            };
        }

        function updateCharts(data) {
            if (!data || !data.acceleration || !data.gyro) {
                console.warn('Invalid data for charts:', data);
                return;
            }

            try {
                const time = new Date().getTime() / 1000;
                
                // 使用extendTraces更新图表
                Plotly.extendTraces('accel-chart', {
                    x: [[time], [time], [time]],
                    y: [[data.acceleration.x], [data.acceleration.y], [data.acceleration.z]]
                }, [0, 1, 2]);

                Plotly.extendTraces('gyro-chart', {
                    x: [[time], [time], [time]],
                    y: [[data.gyro.x], [data.gyro.y], [data.gyro.z]]
                }, [0, 1, 2]);

                // 限制数据点数量，提高性能
                if (dataBuffer.time.length > BUFFER_SIZE) {
                    Plotly.relayout('accel-chart', {
                        xaxis: { range: [time - 10, time] }
                    });
                    Plotly.relayout('gyro-chart', {
                        xaxis: { range: [time - 10, time] }
                    });
                }
            } catch (error) {
                console.error('Error updating charts:', error);
                // 添加错误恢复逻辑
                setTimeout(() => {
                    initCharts();  // 重新初始化图表
                }, 1000);
            }
        }

        function updateDisplayValues(data) {
            try {
                // 存储最后处理的数据
                lastProcessedData = data;

                // 检查数据有效性
                if (!data || !data.acceleration || !data.orientation) {
                    console.warn('Invalid data received:', data);
                    return;
                }

                // 更新加速度显示
                document.getElementById('linear-accel-x').textContent = `${data.acceleration.x.toFixed(3)} m/s²`;
                document.getElementById('linear-accel-y').textContent = `${data.acceleration.y.toFixed(3)} m/s²`;
                document.getElementById('linear-accel-z').textContent = `${data.acceleration.z.toFixed(3)} m/s²`;

                // 如果在校准过程中，处理校准数据
                if (isCalibrating && isCollecting) {
                    console.log('Processing calibration data in updateDisplayValues');
                    processCalibrationData({
                        orientation: {
                            x: data.orientation.x,
                            y: data.orientation.y,
                            z: data.orientation.z
                        }
                    });
                } else {
                    // 正常更新3D可视化
                    updateVisualization(data);
                }

                // 更新图表
                if (data.acceleration) {
                    updateCharts(data);
                }
            } catch (error) {
                console.error('Error updating display values:', error);
            }
        }

        function startDataFetching() {
            console.log('Starting data fetching...');
            return setInterval(() => {
                fetch('/gyro')
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (serverConfig.debug) {
                            console.log('Received data:', data);
                        }

                        // 更新连接状态
                        const statusElement = document.getElementById('connection-status');
                        if (data && data.connection_status) {
                            statusElement.textContent = 'ESP32已连接';
                            statusElement.style.color = '#4CAF50';
                            statusElement.className = 'status connected';

                            // 确保数据格式正确
                            if (data.acceleration && data.orientation) {
                                // 更新所有显示数据
                                updateDisplayValues(data);
                            } else {
                                console.warn('数据格式不完整:', data);
                            }
                        } else {
                            statusElement.textContent = 'ESP32未连接';
                            statusElement.style.color = '#f44336';
                            statusElement.className = 'status disconnected';
                            console.warn('ESP32未连接或数据无效:', data);
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching data:', error);
                        const statusElement = document.getElementById('connection-status');
                        if (statusElement) {
                            statusElement.textContent = 'ESP32未连接';
                            statusElement.style.color = '#f44336';
                            statusElement.className = 'status disconnected';
                        }
                    });
            }, 100);  // 每100ms更新一次
        }

        // 校准按钮事件处理
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Starting visualization...');
            initVisualization();
            initCharts();

            // 绑定校准按钮事件
            const startCalibrationBtn = document.getElementById('startCalibration');
            const resetOrientationBtn = document.getElementById('resetOrientation');

            if (startCalibrationBtn) {
                startCalibrationBtn.addEventListener('click', () => {
                    console.log('Starting calibration...');
                    startCalibration();
                });
            }

            if (resetOrientationBtn) {
                resetOrientationBtn.addEventListener('click', () => {
                    console.log('Resetting orientation...');
                    resetOrientation();
                });
            }

            // 启动数据获取
            const dataInterval = startDataFetching();

            // 添加页面卸载时的清理
            window.addEventListener('beforeunload', () => {
                if (dataInterval) {
                    clearInterval(dataInterval);
                }
            });
        });

        function startCalibration() {
            console.log('Initializing calibration...');
            isCalibrating = true;
            calibrationStep = 1;
            calibrationData = {
                x: [], y: [], z: []
            };

            // 记录开始校准时的姿态作为基准
            if (lastProcessedData && lastProcessedData.orientation) {
                calibrationOffset.initial = {
                    x: lastProcessedData.orientation.x,
                    y: lastProcessedData.orientation.y,
                    z: lastProcessedData.orientation.z
                };
                console.log('Initial orientation set:', calibrationOffset.initial);
            } else {
                calibrationOffset.initial = { x: 0, y: 0, z: 0 };
                console.warn('No initial orientation data available');
            }

            // 禁用开始校准按钮
            const startCalibrationBtn = document.getElementById('startCalibration');
            if (startCalibrationBtn) {
                startCalibrationBtn.disabled = true;
            }

            // 更新校准步骤显示
            updateCalibrationSteps(1);
            // 显示第一步校准指南
            showCalibrationGuide(1);
        }

        function resetOrientation() {
            console.log('Resetting orientation...');

            // 重置3D模型的旋转
            if (cube) {
                cube.rotation.set(0, 0, 0);
                renderer.render(scene, camera);
            }

            // 重置偏移量
            calibrationOffset = {
                horizontal: { x: 0, y: 0, z: 0 },
                vertical: { x: 0, y: 0, z: 0 },
                side: { x: 0, y: 0, z: 0 },
                rotate: { x: 0, y: 0, z: 0 },
                initial: { x: 0, y: 0, z: 0 },
                final: { x: 0, y: 0, z: 0 }
            };

            // 更新状态显示
            const statusElement = document.getElementById('calibrationStatus');
            if (statusElement) {
                statusElement.textContent = '姿态已重置';
            }
        }

        function updateCalibrationSteps(currentStep) {
            const steps = document.querySelectorAll('.step');
            steps.forEach(step => {
                const stepNum = parseInt(step.dataset.step);
                step.classList.remove('active', 'completed');
                if (stepNum < currentStep) {
                    step.classList.add('completed');
                } else if (stepNum === currentStep) {
                    step.classList.add('active');
                }
            });
        }

        function showModal(title, text, btnText = "确定", callback = null) {
            const modal = document.getElementById('calibrationModal');
            const modalTitle = modal.querySelector('.modal-title');
            const modalText = modal.querySelector('#modalText');
            const modalBtn = modal.querySelector('#modalBtn');

            if (modalTitle) modalTitle.textContent = title;
            if (modalText) modalText.textContent = text;
            if (modalBtn) {
                modalBtn.textContent = btnText;
                modalBtn.onclick = () => {
                    modal.style.display = "none";
                    if (callback) callback();
                };
            }

            modal.style.display = "block";
        }

        // 处理窗口大小改变
        let resizeTimeout;
        window.addEventListener('resize', () => {
            if (resizeTimeout) {
                clearTimeout(resizeTimeout);
            }
            resizeTimeout = setTimeout(() => {
                if (renderer && camera) {
                    const container = document.getElementById('visualization');
                    const width = container.clientWidth;
                    const height = container.clientHeight;
                    
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                    renderer.setSize(width, height);
                }
            }, 100);
        });

        function createCalibrationGuideModel() {
            const container = document.createElement('div');
            container.className = 'guide-model-container';

            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            camera.position.set(3, 3, 3);
            camera.lookAt(0, 0, 0);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(200, 200);
            container.appendChild(renderer.domElement);

            // 创建目标设备模型（半透明绿色）
            const targetGeometry = new THREE.BoxGeometry(2, 0.5, 1);
            const targetMaterial = new THREE.MeshPhongMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.5
            });
            const targetDevice = new THREE.Mesh(targetGeometry, targetMaterial);
            scene.add(targetDevice);

            // 创建当前设备模型（红色）
            const currentGeometry = new THREE.BoxGeometry(2, 0.5, 1);
            const currentMaterial = new THREE.MeshPhongMaterial({
                color: 0xff0000
            });
            const currentDevice = new THREE.Mesh(currentGeometry, currentMaterial);
            scene.add(currentDevice);

            // 添加坐标轴
            const axesHelper = new THREE.AxesHelper(2);
            scene.add(axesHelper);

            // 添加光照
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            // 添加轨道控制器
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 3;
            controls.maxDistance = 8;
            controls.maxPolarAngle = Math.PI;

            // 创建角度指示器
            const angleIndicator = document.createElement('div');
            angleIndicator.className = 'angle-indicator';
            container.appendChild(angleIndicator);

            let animationFrameId = null;
            let isDestroyed = false;

            function animate() {
                if (isDestroyed) return;
                animationFrameId = requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }

            // 启动动画循环
            animate();

            function updateGuideModel(currentOrientation, targetOrientation) {
                if (isDestroyed) return;

                // 计算相对于初始姿态的差异
                const initial = calibrationOffset.initial || { x: 0, y: 0, z: 0 };
                const relativeOrientation = {
                    x: currentOrientation.x - initial.x,
                    y: currentOrientation.y - initial.y,
                    z: currentOrientation.z - initial.z
                };

                // 更新当前设备模型的旋转
                currentDevice.rotation.set(
                    THREE.MathUtils.degToRad(relativeOrientation.x),
                    THREE.MathUtils.degToRad(relativeOrientation.y),
                    THREE.MathUtils.degToRad(relativeOrientation.z)
                );

                // 计算目标姿态相对于初始姿态的差异
                const targetRelative = {
                    x: targetOrientation.x - initial.x,
                    y: targetOrientation.y - initial.y,
                    z: targetOrientation.z - initial.z
                };

                // 更新目标设备模型的旋转
                targetDevice.rotation.set(
                    THREE.MathUtils.degToRad(targetRelative.x),
                    THREE.MathUtils.degToRad(targetRelative.y),
                    THREE.MathUtils.degToRad(targetRelative.z)
                );

                // 计算角度差异（相对于目标姿态）
                const diffX = Math.abs(relativeOrientation.x - targetRelative.x);
                const diffY = Math.abs(relativeOrientation.y - targetRelative.y);
                const diffZ = Math.abs(relativeOrientation.z - targetRelative.z);

                // 更新角度指示器
                angleIndicator.textContent = `差异: X: ${diffX.toFixed(1)}° Y: ${diffY.toFixed(1)}° Z: ${diffZ.toFixed(1)}°`;

                renderer.render(scene, camera);
            }

            function destroy() {
                isDestroyed = true;
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
                controls.dispose();
                renderer.dispose();
            }

            return {
                container,
                updateGuideModel,
                destroy
            };
        }

        function getTargetOrientation(step) {
            // 基于初始姿态计算目标姿态
            const initial = calibrationOffset.initial || { x: 0, y: 0, z: 0 };

            switch (step) {
                case 1: // 当前姿态
                    return { ...initial };
                case 2: // 垂直放置（相对于初始姿态旋转90度）
                    return {
                        x: initial.x,
                        y: initial.y + 90,
                        z: initial.z
                    };
                case 3: // 侧放（相对于初始姿态旋转90度）
                    return {
                        x: initial.x + 90,
                        y: initial.y,
                        z: initial.z
                    };
                case 4: // 旋转180度（相对于初始姿态）
                    return {
                        x: initial.x,
                        y: initial.y,
                        z: initial.z + 180
                    };
                default:
                    return { ...initial };
            }
        }

        function showCalibrationGuide(step) {
            console.log('Showing calibration guide for step:', step);
            const modal = document.getElementById('calibrationModal');
            const modalContent = modal.querySelector('.modal-content');
            const modalText = document.getElementById('modalText');
            const modalBtn = document.getElementById('modalBtn');

            // 清空现有内容
            modalContent.innerHTML = '';

            // 创建新的标题
            const title = document.createElement('div');
            title.className = 'modal-title';
            title.textContent = '姿态校准';
            modalContent.appendChild(title);

            // 创建指南内容
            const guideContent = document.createElement('div');
            guideContent.className = 'modal-text';
            modalContent.appendChild(guideContent);

            // 创建3D引导模型
            const guideModel = createCalibrationGuideModel();
            modalContent.appendChild(guideModel.container);

            // 创建稳定性指示器
            const stabilityIndicator = document.createElement('div');
            stabilityIndicator.className = 'stability-indicator';
            stabilityIndicator.textContent = '设备不稳定，请保持静止';
            modalContent.appendChild(stabilityIndicator);

            // 创建新的按钮
            const newBtn = document.createElement('button');
            newBtn.className = 'modal-btn';
            newBtn.textContent = '开始采集';
            newBtn.disabled = false;  // 按钮直接可用
            modalContent.appendChild(newBtn);

            // 获取目标姿态
            const targetOrientation = getTargetOrientation(step);

            // 更新引导文本
            let stepText = '';
            switch (step) {
                case 1:
                    stepText = '请将设备水平放置，正面朝上，点击"开始采集"';
                    break;
                case 2:
                    stepText = '请将设备垂直放置，正面朝Y轴，点击"开始采集"';
                    break;
                case 3:
                    stepText = '请将设备侧放，正面朝X轴，点击"开始采集"';
                    break;
                case 4:
                    stepText = '请将设备旋转180度，正面朝下，点击"开始采集"';
                    break;
            }
            guideContent.textContent = stepText;

            // 设置按钮点击事件
            newBtn.onclick = () => {
                console.log('Start collecting button clicked');
                // 销毁3D模型
                if (guideModel && guideModel.destroy) {
                    guideModel.destroy();
                }
                // 隐藏模态框
                modal.style.display = "none";

                // 开始数据采集
                console.log('Starting data collection for step:', step);
                isCollecting = true;
                calibrationStep = step;
                calibrationData = {
                    x: [], y: [], z: []
                };

                // 更新状态显示
                const statusElement = document.getElementById('calibrationStatus');
                if (statusElement) {
                    statusElement.textContent = '正在采集数据...';
                }
            };

            modal.style.display = "block";
        }

        function startCollectingData(step) {
            console.log('Starting data collection for step:', step);
            isCollecting = true;
            calibrationStep = step;
            calibrationData = {
                x: [], y: [], z: []
            };

            // 更新状态显示
            const statusElement = document.getElementById('calibrationStatus');
            if (statusElement) {
                statusElement.textContent = '正在采集数据...';
            }
        }

        function processCalibrationData(data) {
            try {
                if (!isCalibrating || !isCollecting) {
                    console.log('Not in calibration mode or not collecting:', { isCalibrating, isCollecting });
                    return;
                }

                console.log('Processing calibration data:', data);

                // 添加数据到校准数组
                calibrationData.x.push(data.orientation.x);
                calibrationData.y.push(data.orientation.y);
                calibrationData.z.push(data.orientation.z);

                // 更新状态显示
                const statusElement = document.getElementById('calibrationStatus');
                if (statusElement) {
                    statusElement.textContent = `正在采集数据...(${calibrationData.x.length}/${CALIBRATION_SAMPLES})`;
                }

                // 检查是否收集了足够的样本
                if (calibrationData.x.length >= CALIBRATION_SAMPLES) {
                    console.log('Collected enough samples, calculating offsets...');

                    // 计算平均值
                    const avgX = calibrationData.x.reduce((a, b) => a + b, 0) / CALIBRATION_SAMPLES;
                    const avgY = calibrationData.y.reduce((a, b) => a + b, 0) / CALIBRATION_SAMPLES;
                    const avgZ = calibrationData.z.reduce((a, b) => a + b, 0) / CALIBRATION_SAMPLES;

                    // 根据当前步骤存储偏移量
                    switch (calibrationStep) {
                        case 1:
                            calibrationOffset.horizontal = { x: avgX, y: avgY, z: avgZ };
                            break;
                        case 2:
                            calibrationOffset.vertical = { x: avgX, y: avgY, z: avgZ };
                            break;
                        case 3:
                            calibrationOffset.side = { x: avgX, y: avgY, z: avgZ };
                            break;
                        case 4:
                            calibrationOffset.rotate = { x: avgX, y: avgY, z: avgZ };
                            break;
                    }

                    // 停止采集
                    isCollecting = false;

                    // 如果是最后一步，完成校准
                    if (calibrationStep === 4) {
                        console.log('Calibration complete, calculating final offsets...');
                        calculateFinalOffset();
                        isCalibrating = false;

                        // 启用开始校准按钮
                        const startCalibrationBtn = document.getElementById('startCalibration');
                        if (startCalibrationBtn) {
                            startCalibrationBtn.disabled = false;
                        }

                        // 显示完成消息
                        if (statusElement) {
                            statusElement.textContent = '校准完成';
                        }
                    } else {
                        // 显示下一步
                        console.log('Moving to next step...');
                        setTimeout(() => {
                            showCalibrationGuide(calibrationStep + 1);
                        }, 1000);
                    }
                }
            } catch (error) {
                console.error('Error processing calibration data:', error);
            }
        }

        function calculateStandardDeviation(values) {
            const n = values.length;
            const mean = values.reduce((a, b) => a + b, 0) / n;
            const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / n;
            return Math.sqrt(variance);
        }

        function calculateFinalOffset() {
            // 使用水平位置作为基准
            calibrationOffset.final = {
                x: calibrationOffset.horizontal.x,
                y: calibrationOffset.horizontal.y,
                z: calibrationOffset.horizontal.z
            };

            console.log('Final calibration offsets:', calibrationOffset.final);
        }

        // 添加电机控制函数
        function setMotor(motor, speed) {
            currentMotorSpeed = speed;
            document.getElementById('speedSlider').value = speed;
            document.getElementById('motorSpeed').textContent = speed;

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'motor',
                    motor: motor,
                    speed: speed
                }));
            }
        }

        function updateMotorSpeed(speed) {
            currentMotorSpeed = parseInt(speed);
            document.getElementById('motorSpeed').textContent = speed;

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'motor',
                    motor: 1,
                    speed: currentMotorSpeed
                }));
            }
        }

        // 添加遥感控制
        let joystick = document.getElementById('joystick');
        let isDragging = false;
        let centerX, centerY;

        // 遥感初始化
        function initJoystick() {
            const container = joystick.parentElement;
            centerX = container.offsetWidth / 2;
            centerY = container.offsetHeight / 2;

            // 鼠标事件
            joystick.addEventListener('mousedown', startDragging);
            document.addEventListener('mousemove', moveJoystick);
            document.addEventListener('mouseup', stopDragging);

            // 触摸事件
            joystick.addEventListener('touchstart', startDragging);
            document.addEventListener('touchmove', moveJoystick);
            document.addEventListener('touchend', stopDragging);
        }

        function startDragging(e) {
            isDragging = true;
            e.preventDefault();
        }

        function moveJoystick(e) {
            if (!isDragging) return;

            const container = joystick.parentElement;
            const rect = container.getBoundingClientRect();
            const maxDistance = (container.offsetWidth - joystick.offsetWidth) / 2;

            let clientX, clientY;
            if (e.type === 'touchmove') {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            let x = clientX - rect.left - centerX;
            let y = clientY - rect.top - centerY;

            // 限制在圆形范围内
            const distance = Math.sqrt(x * x + y * y);
            if (distance > maxDistance) {
                x = (x / distance) * maxDistance;
                y = (y / distance) * maxDistance;
            }

            joystick.style.left = (centerX + x - joystick.offsetWidth / 2) + 'px';
            joystick.style.top = (centerY + y - joystick.offsetHeight / 2) + 'px';

            // 计算速度和转向
            const speed = -Math.round((y / maxDistance) * 100);
            const turn = Math.round((x / maxDistance) * 100);

            updateControl(speed, turn);
        }

        function stopDragging() {
            if (!isDragging) return;
            isDragging = false;

            // 回到中心位置
            joystick.style.left = (centerX - joystick.offsetWidth / 2) + 'px';
            joystick.style.top = (centerY - joystick.offsetHeight / 2) + 'px';

            updateControl(0, 0);
        }

        // 添加键盘控制
        document.addEventListener('keydown', function (e) {
            if (e.repeat) return;

            switch (e.key.toLowerCase()) {
                case 'w':
                    updateControl(100, 0);
                    break;
                case 's':
                    updateControl(-100, 0);
                    break;
                case 'a':
                    updateControl(0, -100);
                    break;
                case 'd':
                    updateControl(0, 100);
                    break;
                case ' ':
                    updateControl(0, 0);
                    break;
            }
        });
    </script>
</body>

</html>